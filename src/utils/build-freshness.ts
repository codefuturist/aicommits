import { execSync } from 'child_process';
import { readFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

export interface BuildMeta {
	srcTreeHash: string;
	srcFingerprint?: string;
	gitCommit: string;
	gitCommitFull: string;
	builtAt: string;
}

export interface ProjectType {
	name: string;
	buildCommand: string;
	sourceDir: string;
}

export interface FreshnessResult {
	fresh: boolean;
	meta: BuildMeta | null;
	currentHash: string | null;
	projectType: ProjectType | null;
	reason: string;
}

// Strategy pattern: detect project type from indicator files
const PROJECT_STRATEGIES: Array<{
	indicator: string | string[];
	type: ProjectType;
}> = [
	{
		indicator: 'Cargo.toml',
		type: { name: 'Rust (cargo)', buildCommand: 'cargo build --release', sourceDir: 'src' },
	},
	{
		indicator: 'go.mod',
		type: { name: 'Go', buildCommand: 'go build ./...', sourceDir: '.' },
	},
	{
		indicator: 'justfile',
		type: { name: 'Just', buildCommand: 'just build', sourceDir: 'src' },
	},
	{
		indicator: 'Taskfile.yml',
		type: { name: 'Task', buildCommand: 'task build', sourceDir: 'src' },
	},
	{
		indicator: 'Makefile',
		type: { name: 'Make', buildCommand: 'make', sourceDir: 'src' },
	},
	{
		indicator: 'CMakeLists.txt',
		type: { name: 'C/C++ (CMake)', buildCommand: 'cmake --build build', sourceDir: 'src' },
	},
	{
		indicator: 'pnpm-lock.yaml',
		type: { name: 'Node.js (pnpm)', buildCommand: 'pnpm run build', sourceDir: 'src' },
	},
	{
		indicator: ['bun.lock', 'bun.lockb'],
		type: { name: 'Node.js (bun)', buildCommand: 'bun run build', sourceDir: 'src' },
	},
	{
		indicator: 'yarn.lock',
		type: { name: 'Node.js (yarn)', buildCommand: 'yarn build', sourceDir: 'src' },
	},
	{
		indicator: 'package-lock.json',
		type: { name: 'Node.js (npm)', buildCommand: 'npm run build', sourceDir: 'src' },
	},
	{
		indicator: 'pyproject.toml',
		type: { name: 'Python', buildCommand: 'python -m build', sourceDir: 'src' },
	},
	{
		indicator: 'setup.py',
		type: { name: 'Python (legacy)', buildCommand: 'python setup.py build', sourceDir: '.' },
	},
	// Fallback for any Node.js project without a lockfile
	{
		indicator: 'package.json',
		type: { name: 'Node.js (npm)', buildCommand: 'npm run build', sourceDir: 'src' },
	},
];

function git(cmd: string, cwd: string): string | null {
	try {
		return execSync(`git ${cmd}`, {
			encoding: 'utf8',
			cwd,
			stdio: ['pipe', 'pipe', 'pipe'],
		}).trim();
	} catch {
		return null;
	}
}

function getSourceFingerprint(cwd: string, sourceDir: string): string | null {
	try {
		const result = execSync(
			`find ${sourceDir} -name "*.ts" -type f -print0 | sort -z | xargs -0 shasum | shasum`,
			{ encoding: 'utf8', cwd, stdio: ['pipe', 'pipe', 'pipe'] },
		).trim();
		return result.split(/\s/)[0] || null;
	} catch {
		return null;
	}
}

function getProjectRoot(): string {
	const thisFile = fileURLToPath(import.meta.url);
	// dist/cli.mjs → project root (go up from dist/)
	let dir = dirname(thisFile);
	for (let i = 0; i < 5; i++) {
		if (existsSync(join(dir, 'package.json'))) return dir;
		dir = dirname(dir);
	}
	return dirname(thisFile);
}

export function detectProjectType(projectRoot: string): ProjectType | null {
	for (const strategy of PROJECT_STRATEGIES) {
		const indicators = Array.isArray(strategy.indicator)
			? strategy.indicator
			: [strategy.indicator];
		if (indicators.some((f) => existsSync(join(projectRoot, f)))) {
			return { ...strategy.type };
		}
	}
	return null;
}

export function isDevInstall(): boolean {
	const projectRoot = getProjectRoot();
	const metaPath = join(projectRoot, 'dist', '.build-meta.json');
	// Dev install: has .build-meta.json (generated by postbuild) OR is in a git repo with src/
	return (
		existsSync(metaPath) ||
		(existsSync(join(projectRoot, '.git')) && existsSync(join(projectRoot, 'src')))
	);
}

export function readBuildMeta(): BuildMeta | null {
	const projectRoot = getProjectRoot();
	const metaPath = join(projectRoot, 'dist', '.build-meta.json');
	try {
		const raw = readFileSync(metaPath, 'utf8');
		return JSON.parse(raw) as BuildMeta;
	} catch {
		return null;
	}
}

export function checkBuildFreshness(
	sourceDirOverride?: string,
): FreshnessResult {
	const projectRoot = getProjectRoot();
	const meta = readBuildMeta();
	const projectType = detectProjectType(projectRoot);
	const sourceDir = sourceDirOverride || projectType?.sourceDir || 'src';

	// Not in a git repo → can't check
	const isGitRepo = git('rev-parse --is-inside-work-tree', projectRoot);
	if (!isGitRepo) {
		return { fresh: true, meta, currentHash: null, projectType, reason: 'Not in a git repo' };
	}

	const currentHash = git(`rev-parse HEAD:${sourceDir}`, projectRoot);
	if (!currentHash) {
		return { fresh: true, meta, currentHash: null, projectType, reason: `No git tree for ${sourceDir}/` };
	}

	if (!meta) {
		return { fresh: false, meta: null, currentHash, projectType, reason: 'No .build-meta.json found (never built or first run)' };
	}

	if (meta.srcTreeHash === currentHash) {
		// Tree hash matches committed state — also check for uncommitted changes
		if (meta.srcFingerprint) {
			const currentFingerprint = getSourceFingerprint(projectRoot, sourceDir);
			if (currentFingerprint && currentFingerprint !== meta.srcFingerprint) {
				return { fresh: false, meta, currentHash, projectType, reason: 'Build is stale — uncommitted source changes detected' };
			}
		}
		return { fresh: true, meta, currentHash, projectType, reason: 'Build is up to date' };
	}

	// Get info about what changed
	const commitsBehind = git(
		`rev-list --count ${meta.gitCommitFull}..HEAD -- ${sourceDir}`,
		projectRoot,
	);
	const behind = commitsBehind ? `${commitsBehind} commit(s) with src changes` : 'source changed';

	return {
		fresh: false,
		meta,
		currentHash,
		projectType,
		reason: `Build is stale — ${behind}`,
	};
}

export function getCurrentCommitShort(): string | null {
	return git('rev-parse --short HEAD', getProjectRoot());
}

export function getProjectRootPath(): string {
	return getProjectRoot();
}

export function didCommitChangeSource(sourceDir?: string): boolean {
	const projectRoot = getProjectRoot();
	const projectType = detectProjectType(projectRoot);
	const dir = sourceDir || projectType?.sourceDir || 'src';

	try {
		const diff = execSync(`git diff --name-only HEAD~1..HEAD -- ${dir}`, {
			encoding: 'utf8',
			cwd: projectRoot,
			stdio: ['pipe', 'pipe', 'pipe'],
		}).trim();
		return diff.length > 0;
	} catch {
		// First commit or other error — assume changed
		return true;
	}
}

export function getCurrentBranch(): string | null {
	const projectRoot = getProjectRoot();
	return git('rev-parse --abbrev-ref HEAD', projectRoot);
}

export function getHeadTags(): string[] {
	const projectRoot = getProjectRoot();
	try {
		const result = execSync('git tag --points-at HEAD', {
			encoding: 'utf8',
			cwd: projectRoot,
			stdio: ['pipe', 'pipe', 'pipe'],
		}).trim();
		return result ? result.split('\n').map((t) => t.trim()).filter(Boolean) : [];
	} catch {
		return [];
	}
}

export function matchesGlobPattern(value: string, pattern: string): boolean {
	// Convert glob pattern to regex: * → [^/]*, ** → .*, ? → .
	const regexStr = pattern
		.replace(/\*\*/g, '{{GLOBSTAR}}')
		.replace(/\*/g, '[^/]*')
		.replace(/\?/g, '.')
		.replace(/\{\{GLOBSTAR\}\}/g, '.*');
	return new RegExp(`^${regexStr}$`).test(value);
}
